<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Command - Version 8</title>
    <!-- 
    VERSION 8: Major improvements
    - Fixed Play Again button (game over screen properly clears)
    - Pyramid/triangle ammo display in silos
    - Cities and bases gray out when destroyed (not red)
    - Intro sequence with drum beats as cities/bases appear
    - Victory fanfare at end of wave
    -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function MissileCommand() {
          const mountRef = useRef(null);
          const [score, setScore] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [wave, setWave] = useState(1);
          const [ammo, setAmmo] = useState(30);
          const [cities, setCities] = useState(6);
          const [gameState, setGameState] = useState('intro'); // intro, playing, gameover

          useEffect(() => {
            if (!mountRef.current) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            mountRef.current.appendChild(renderer.domElement);

            // Game state
            const game = {
              cities: [],
              silos: [],
              enemyMissiles: [],
              playerMissiles: [],
              explosions: [],
              score: 0,
              citiesAlive: 6,
              totalAmmo: 30,
              wave: 1,
              state: 'intro',
              introStep: 0,
              introTimer: 0
            };

            // Create audio context ONCE
            let audioCtx = null;
            const getAudioContext = () => {
              if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
              }
              return audioCtx;
            };

            const playSound = (type) => {
              try {
                const ctx = getAudioContext();
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                if (type === 'drum') {
                  oscillator.type = 'triangle';
                  oscillator.frequency.setValueAtTime(100, ctx.currentTime);
                  oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1);
                  gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                  oscillator.start(ctx.currentTime);
                  oscillator.stop(ctx.currentTime + 0.1);
                } else if (type === 'launch') {
                  oscillator.frequency.setValueAtTime(200, ctx.currentTime);
                  oscillator.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
                  gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                  oscillator.start(ctx.currentTime);
                  oscillator.stop(ctx.currentTime + 0.1);
                } else if (type === 'explosion') {
                  oscillator.type = 'sawtooth';
                  oscillator.frequency.setValueAtTime(150, ctx.currentTime);
                  oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
                  gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                  oscillator.start(ctx.currentTime);
                  oscillator.stop(ctx.currentTime + 0.3);
                } else if (type === 'smallExplosion') {
                  oscillator.type = 'sawtooth';
                  oscillator.frequency.setValueAtTime(100, ctx.currentTime);
                  oscillator.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.2);
                  gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                  oscillator.start(ctx.currentTime);
                  oscillator.stop(ctx.currentTime + 0.2);
                } else if (type === 'cityDestroyed') {
                  oscillator.type = 'square';
                  oscillator.frequency.setValueAtTime(300, ctx.currentTime);
                  oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.5);
                  gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                  oscillator.start(ctx.currentTime);
                  oscillator.stop(ctx.currentTime + 0.5);
                } else if (type === 'fanfare') {
                  // Play a victory fanfare with multiple notes
                  const notes = [262, 330, 392, 523]; // C, E, G, high C
                  notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.3);
                    osc.start(ctx.currentTime + i * 0.15);
                    osc.stop(ctx.currentTime + i * 0.15 + 0.3);
                  });
                  return; // Don't execute the code below
                }
              } catch (e) {
                console.log('Audio error:', e);
              }
            };

            // Create missile silos (3 silos with 10 missiles each)
            const siloPositions = [-40, 0, 40];
            for (let i = 0; i < 3; i++) {
              const siloGroup = new THREE.Group();
              
              // Silo base
              const siloGeometry = new THREE.BoxGeometry(4, 3, 1);
              const siloMaterial = new THREE.MeshBasicMaterial({ color: 0x0088ff });
              const silo = new THREE.Mesh(siloGeometry, siloMaterial);
              siloGroup.add(silo);
              
              // Ammo indicators in triangle/pyramid formation (10 missiles)
              const ammoIndicators = [];
              let ballIndex = 0;
              // Row 1: 4 balls
              for (let j = 0; j < 4; j++) {
                const ammoGeometry = new THREE.CircleGeometry(0.25, 8);
                const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
                ammo.position.set(-1.125 + j * 0.75, -0.3, 0.1);
                siloGroup.add(ammo);
                ammoIndicators.push(ammo);
                ballIndex++;
              }
              // Row 2: 3 balls
              for (let j = 0; j < 3; j++) {
                const ammoGeometry = new THREE.CircleGeometry(0.25, 8);
                const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
                ammo.position.set(-0.75 + j * 0.75, 0.2, 0.1);
                siloGroup.add(ammo);
                ammoIndicators.push(ammo);
                ballIndex++;
              }
              // Row 3: 2 balls
              for (let j = 0; j < 2; j++) {
                const ammoGeometry = new THREE.CircleGeometry(0.25, 8);
                const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
                ammo.position.set(-0.375 + j * 0.75, 0.7, 0.1);
                siloGroup.add(ammo);
                ammoIndicators.push(ammo);
                ballIndex++;
              }
              // Row 4: 1 ball (top)
              const ammoGeometry = new THREE.CircleGeometry(0.25, 8);
              const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
              const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
              ammo.position.set(0, 1.2, 0.1);
              siloGroup.add(ammo);
              ammoIndicators.push(ammo);
              
              siloGroup.position.set(siloPositions[i], -20, 0);
              siloGroup.visible = false; // Hidden until intro
              scene.add(siloGroup);
              
              game.silos.push({
                group: siloGroup,
                baseMesh: silo,
                position: new THREE.Vector3(siloPositions[i], -20, 0),
                ammo: 10,
                indicators: ammoIndicators,
                alive: true
              });
            }

            // Create cities (6 cities at the bottom)
            const cityGeometry = new THREE.BoxGeometry(3, 2, 1);
            const cityMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            const cityPositions = [-30, -20, -10, 10, 20, 30];
            for (let i = 0; i < 6; i++) {
              const city = new THREE.Mesh(cityGeometry, cityMaterial);
              city.position.set(cityPositions[i], -20, 0);
              city.userData.alive = true;
              city.visible = false; // Hidden until intro
              scene.add(city);
              game.cities.push(city);
            }

            // Ground line
            const groundGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(-50, -22, 0),
              new THREE.Vector3(50, -22, 0)
            ]);
            const groundMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const ground = new THREE.Line(groundGeometry, groundMaterial);
            scene.add(ground);

            // Crosshair
            const crosshairGroup = new THREE.Group();
            const crosshairGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0)
            ]);
            const crosshairGeometry2 = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0)
            ]);
            const crosshairMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const crosshairH = new THREE.Line(crosshairGeometry, crosshairMaterial);
            const crosshairV = new THREE.Line(crosshairGeometry2, crosshairMaterial);
            crosshairGroup.add(crosshairH);
            crosshairGroup.add(crosshairV);
            crosshairGroup.visible = false; // Hidden until game starts
            scene.add(crosshairGroup);

            // Mouse position
            const mouse = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();

            const onMouseMove = (event) => {
              mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
              mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
              
              raycaster.setFromCamera(mouse, camera);
              const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
              const intersectPoint = new THREE.Vector3();
              raycaster.ray.intersectPlane(plane, intersectPoint);
              
              crosshairGroup.position.copy(intersectPoint);
            };

            const onMouseClick = () => {
              if (game.state !== 'playing' || game.totalAmmo <= 0 || game.citiesAlive === 0) return;

              const targetPos = crosshairGroup.position.clone();
              
              // Find nearest silo with ammo
              let launchSilo = null;
              let minDist = Infinity;
              for (const silo of game.silos) {
                if (silo.ammo > 0 && silo.alive) {
                  const dist = silo.position.distanceTo(targetPos);
                  if (dist < minDist) {
                    minDist = dist;
                    launchSilo = silo;
                  }
                }
              }

              if (launchSilo) {
                const missile = {
                  start: launchSilo.position.clone(),
                  end: targetPos.clone(),
                  current: launchSilo.position.clone(),
                  progress: 0,
                  speed: 0.008,
                  line: null
                };

                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                  missile.start,
                  missile.current
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
                missile.line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(missile.line);

                game.playerMissiles.push(missile);
                game.totalAmmo--;
                launchSilo.ammo--;
                
                // Hide ammo indicator from top down (pyramid order)
                if (launchSilo.indicators[launchSilo.ammo]) {
                  launchSilo.indicators[launchSilo.ammo].visible = false;
                }
                
                setAmmo(game.totalAmmo);
                playSound('launch');
              }
            };

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            // Spawn enemy missiles
            const spawnEnemyMissile = () => {
              if (game.citiesAlive === 0) return;

              const startX = (Math.random() - 0.5) * 100;
              
              // Target random city or silo
              const targets = [];
              game.cities.forEach(city => {
                if (city.userData.alive) targets.push(city.position);
              });
              game.silos.forEach(silo => {
                if (silo.alive) targets.push(silo.position);
              });
              
              if (targets.length === 0) return;
              
              const targetPos = targets[Math.floor(Math.random() * targets.length)];
              
              const missile = {
                start: new THREE.Vector3(startX, 30, 0),
                end: targetPos.clone(),
                current: new THREE.Vector3(startX, 30, 0),
                progress: 0,
                speed: 0.0008 + Math.random() * 0.0007,
                line: null
              };

              const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                missile.start,
                missile.current
              ]);
              const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
              missile.line = new THREE.Line(lineGeometry, lineMaterial);
              scene.add(missile.line);

              game.enemyMissiles.push(missile);
            };

            // Create explosion
            const createExplosion = (position, isPlayer = false) => {
              const explosion = {
                position: position.clone(),
                radius: 0,
                maxRadius: isPlayer ? 8 : 3,
                expanding: true,
                duration: isPlayer ? 120 : 60,
                life: 0,
                circle: null
              };

              const segments = 32;
              const circleGeometry = new THREE.BufferGeometry();
              const positions = new Float32Array((segments + 1) * 3);
              for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                positions[i * 3] = Math.cos(theta);
                positions[i * 3 + 1] = Math.sin(theta);
                positions[i * 3 + 2] = 0;
              }
              circleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
              
              const circleMaterial = new THREE.LineBasicMaterial({ 
                color: isPlayer ? 0xffffff : 0xff8800 
              });
              explosion.circle = new THREE.LineLoop(circleGeometry, circleMaterial);
              explosion.circle.position.copy(position);
              scene.add(explosion.circle);

              game.explosions.push(explosion);
              playSound(isPlayer ? 'explosion' : 'smallExplosion');
            };

            // Game loop
            let enemySpawnTimer = 0;
            let waveEnemiesSpawned = 0;
            const enemiesPerWave = 10;

            const animate = () => {
              requestAnimationFrame(animate);

              // Handle intro sequence
              if (game.state === 'intro') {
                game.introTimer++;
                if (game.introTimer > 20) {
                  if (game.introStep < 3) {
                    // Show silos
                    game.silos[game.introStep].group.visible = true;
                    playSound('drum');
                    game.introStep++;
                    game.introTimer = 0;
                  } else if (game.introStep < 9) {
                    // Show cities
                    game.cities[game.introStep - 3].visible = true;
                    playSound('drum');
                    game.introStep++;
                    game.introTimer = 0;
                  } else {
                    // Start game
                    game.state = 'playing';
                    crosshairGroup.visible = true;
                    setGameState('playing');
                  }
                }
              }

              // Only run game logic when playing
              if (game.state === 'playing') {
                // Spawn enemies
                if (waveEnemiesSpawned < enemiesPerWave + game.wave * 5) {
                  enemySpawnTimer++;
                  if (enemySpawnTimer > 150 - game.wave * 10) {
                    spawnEnemyMissile();
                    enemySpawnTimer = 0;
                    waveEnemiesSpawned++;
                  }
                }

                // Update player missiles
                for (let i = game.playerMissiles.length - 1; i >= 0; i--) {
                  const missile = game.playerMissiles[i];
                  missile.progress += missile.speed;

                  if (missile.progress >= 1) {
                    createExplosion(missile.end, true);
                    scene.remove(missile.line);
                    game.playerMissiles.splice(i, 1);
                  } else {
                    missile.current.lerpVectors(missile.start, missile.end, missile.progress);
                    const positions = missile.line.geometry.attributes.position.array;
                    positions[3] = missile.current.x;
                    positions[4] = missile.current.y;
                    positions[5] = missile.current.z;
                    missile.line.geometry.attributes.position.needsUpdate = true;
                  }
                }

                // Update enemy missiles
                for (let i = game.enemyMissiles.length - 1; i >= 0; i--) {
                  const missile = game.enemyMissiles[i];
                  missile.progress += missile.speed;

                  if (missile.progress >= 1) {
                    createExplosion(missile.end, false);
                    
                    // Destroy city if hit
                    for (const city of game.cities) {
                      if (city.userData.alive && city.position.distanceTo(missile.end) < 3) {
                        city.userData.alive = false;
                        city.material.color.setHex(0x333333); // Gray out
                        game.citiesAlive--;
                        setCities(game.citiesAlive);
                        playSound('cityDestroyed');
                      }
                    }
                    
                    // Destroy silo if hit
                    for (const silo of game.silos) {
                      if (silo.alive && silo.position.distanceTo(missile.end) < 3) {
                        silo.alive = false;
                        silo.baseMesh.material.color.setHex(0x333333); // Gray out
                        // Gray out remaining ammo
                        for (const indicator of silo.indicators) {
                          if (indicator.visible) {
                            indicator.material.color.setHex(0x666666);
                          }
                        }
                        playSound('cityDestroyed');
                      }
                    }

                    scene.remove(missile.line);
                    game.enemyMissiles.splice(i, 1);
                  } else {
                    missile.current.lerpVectors(missile.start, missile.end, missile.progress);
                    const positions = missile.line.geometry.attributes.position.array;
                    positions[3] = missile.current.x;
                    positions[4] = missile.current.y;
                    positions[5] = missile.current.z;
                    missile.line.geometry.attributes.position.needsUpdate = true;
                  }
                }

                // Update explosions and check collisions
                for (let i = game.explosions.length - 1; i >= 0; i--) {
                  const explosion = game.explosions[i];
                  explosion.life++;

                  if (explosion.expanding) {
                    explosion.radius += explosion.maxRadius / 30;
                    if (explosion.radius >= explosion.maxRadius) {
                      explosion.expanding = false;
                    }
                  }

                  explosion.circle.scale.set(explosion.radius, explosion.radius, 1);

                  // Check collision with enemy missiles
                  if (explosion.radius > 0) {
                    for (let j = game.enemyMissiles.length - 1; j >= 0; j--) {
                      const missile = game.enemyMissiles[j];
                      if (missile.current.distanceTo(explosion.position) < explosion.radius) {
                        createExplosion(missile.current, false);
                        scene.remove(missile.line);
                        game.enemyMissiles.splice(j, 1);
                        game.score += 25;
                      }
                    }
                  }

                  if (explosion.life >= explosion.duration) {
                    scene.remove(explosion.circle);
                    game.explosions.splice(i, 1);
                  }
                }

                // Check for wave completion
                if (game.enemyMissiles.length === 0 && 
                    waveEnemiesSpawned >= enemiesPerWave + game.wave * 5 &&
                    game.citiesAlive > 0) {
                  game.wave++;
                  game.score += game.citiesAlive * 100;
                  
                  // Play fanfare
                  playSound('fanfare');
                  
                  // Refill all alive silos
                  for (const silo of game.silos) {
                    if (silo.alive) {
                      const refillAmount = 10 - silo.ammo;
                      silo.ammo = 10;
                      game.totalAmmo += refillAmount;
                      for (let i = 0; i < 10; i++) {
                        silo.indicators[i].visible = true;
                        silo.indicators[i].material.color.setHex(0xffff00);
                      }
                    }
                  }
                  
                  waveEnemiesSpawned = 0;
                  setWave(game.wave);
                  setAmmo(game.totalAmmo);
                }

                // Check game over
                if (game.citiesAlive === 0) {
                  game.state = 'gameover';
                  setGameOver(true);
                  setGameState('gameover');
                }

                setScore(game.score);
              }
              
              renderer.render(scene, camera);
            };

            animate();

            // Handle resize
            const handleResize = () => {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', handleResize);

            // Cleanup
            return () => {
              window.removeEventListener('mousemove', onMouseMove);
              window.removeEventListener('click', onMouseClick);
              window.removeEventListener('resize', handleResize);
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
              if (audioCtx) {
                audioCtx.close();
              }
            };
          }, []);

          const restartGame = () => {
            // Force page reload for clean restart
            window.location.reload();
          };

          return (
            <div className="relative w-full h-screen overflow-hidden bg-black">
              <div ref={mountRef} className="w-full h-full" />
              
              {gameState === 'playing' && (
                <div className="absolute top-4 left-4 text-green-400 font-mono text-xl">
                  <div>SCORE: {score}</div>
                  <div>WAVE: {wave}</div>
                  <div>AMMO: {ammo}</div>
                  <div>CITIES: {cities}</div>
                </div>
              )}

              {gameState === 'intro' && (
                <div className="absolute inset-0 flex items-center justify-center">
                  <div className="text-center">
                    <h1 className="text-5xl font-bold text-green-400 mb-4">MISSILE COMMAND</h1>
                    <p className="text-2xl text-white">Preparing defenses...</p>
                  </div>
                </div>
              )}

              {gameState === 'gameover' && (
                <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90">
                  <div className="text-center">
                    <h1 className="text-6xl font-bold text-red-500 mb-4">GAME OVER</h1>
                    <p className="text-3xl text-white mb-2">Final Score: {score}</p>
                    <p className="text-xl text-white mb-8">Wave: {wave}</p>
                    <button
                      onClick={restartGame}
                      className="px-8 py-4 bg-green-500 text-white text-2xl font-bold rounded hover:bg-green-600 transition-colors"
                    >
                      PLAY AGAIN
                    </button>
                  </div>
                </div>
              )}

              {gameState === 'playing' && (
                <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-white text-sm font-mono text-center">
                  <p>Click to fire missiles at incoming threats</p>
                  <p>Protect your cities and bases!</p>
                </div>
              )}
            </div>
          );
        }

        ReactDOM.render(<MissileCommand />, document.getElementById('root'));
    </script>
</body>
</html>
