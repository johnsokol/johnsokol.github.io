<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Command - Version 4</title>
    <!-- 
    VERSION 4: Fixed lockup issue - standalone HTML
    - Slower missile speeds
    - 3 missile silos with visual ammo counters
    - Sound effects (launch, explosion, city destroyed)
    - Fixed: Removed gameOver from useEffect dependency to prevent re-initialization
    -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function MissileCommand() {
          const mountRef = useRef(null);
          const [score, setScore] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [wave, setWave] = useState(1);
          const gameStateRef = useRef({
            cities: [],
            silos: [],
            enemyMissiles: [],
            playerMissiles: [],
            explosions: [],
            score: 0,
            citiesAlive: 6,
            wave: 1
          });

          useEffect(() => {
            if (!mountRef.current) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            mountRef.current.appendChild(renderer.domElement);

            // Game objects
            const gameState = gameStateRef.current;

            // Create missile silos (3 silos with 10 missiles each)
            const siloPositions = [-40, 0, 40];
            for (let i = 0; i < 3; i++) {
              const siloGroup = new THREE.Group();
              
              // Silo base
              const siloGeometry = new THREE.BoxGeometry(4, 3, 1);
              const siloMaterial = new THREE.MeshBasicMaterial({ color: 0x0088ff });
              const silo = new THREE.Mesh(siloGeometry, siloMaterial);
              siloGroup.add(silo);
              
              // Ammo indicators (10 missiles per silo)
              const ammoIndicators = [];
              for (let j = 0; j < 10; j++) {
                const ammoGeometry = new THREE.CircleGeometry(0.3, 8);
                const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
                const row = Math.floor(j / 5);
                const col = j % 5;
                ammo.position.set(-1.5 + col * 0.75, 1 - row * 0.75, 0.1);
                siloGroup.add(ammo);
                ammoIndicators.push(ammo);
              }
              
              siloGroup.position.set(siloPositions[i], -20, 0);
              scene.add(siloGroup);
              
              gameState.silos.push({
                group: siloGroup,
                position: siloGroup.position.clone(),
                ammo: 10,
                indicators: ammoIndicators
              });
            }

            // Create cities (6 cities at the bottom, between silos)
            const cityGeometry = new THREE.BoxGeometry(3, 2, 1);
            const cityMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            const cityPositions = [-30, -20, -10, 10, 20, 30];
            for (let i = 0; i < 6; i++) {
              const city = new THREE.Mesh(cityGeometry, cityMaterial);
              city.position.set(cityPositions[i], -20, 0);
              city.userData.alive = true;
              scene.add(city);
              gameState.cities.push(city);
            }

            // Ground line
            const groundGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(-50, -22, 0),
              new THREE.Vector3(50, -22, 0)
            ]);
            const groundMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const ground = new THREE.Line(groundGeometry, groundMaterial);
            scene.add(ground);

            // Crosshair
            const crosshairGroup = new THREE.Group();
            const crosshairGeometry = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(-1, 0, 0), new THREE.Vector3(1, 0, 0)
            ]);
            const crosshairGeometry2 = new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 1, 0)
            ]);
            const crosshairMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const crosshairH = new THREE.Line(crosshairGeometry, crosshairMaterial);
            const crosshairV = new THREE.Line(crosshairGeometry2, crosshairMaterial);
            crosshairGroup.add(crosshairH);
            crosshairGroup.add(crosshairV);
            scene.add(crosshairGroup);

            // Mouse position
            const mouse = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();

            // Audio context for sound effects
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const playLaunchSound = () => {
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
              
              gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
              
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.1);
            };
            
            const playExplosionSound = (isPlayer = false) => {
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              oscillator.type = 'sawtooth';
              if (isPlayer) {
                oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                oscillator.stop(audioContext.currentTime + 0.3);
              } else {
                oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.stop(audioContext.currentTime + 0.2);
              }
              
              oscillator.start(audioContext.currentTime);
            };
            
            const playCityDestroyedSound = () => {
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              oscillator.type = 'square';
              oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
              
              gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
              
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.5);
            };

            const onMouseMove = (event) => {
              mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
              mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
              
              raycaster.setFromCamera(mouse, camera);
              const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
              const intersectPoint = new THREE.Vector3();
              raycaster.ray.intersectPlane(plane, intersectPoint);
              
              crosshairGroup.position.copy(intersectPoint);
            };

            const onMouseClick = () => {
              if (gameState.citiesAlive === 0) return;

              const targetPos = crosshairGroup.position.clone();
              
              // Find nearest silo with ammo
              let launchSilo = null;
              let minDist = Infinity;
              for (const silo of gameState.silos) {
                if (silo.ammo > 0) {
                  const dist = silo.position.distanceTo(targetPos);
                  if (dist < minDist) {
                    minDist = dist;
                    launchSilo = silo;
                  }
                }
              }

              if (launchSilo) {
                const missile = {
                  start: launchSilo.position.clone(),
                  end: targetPos.clone(),
                  current: launchSilo.position.clone(),
                  progress: 0,
                  speed: 0.008,
                  line: null
                };

                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                  missile.start,
                  missile.current
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
                missile.line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(missile.line);

                gameState.playerMissiles.push(missile);
                
                // Update silo ammo
                launchSilo.ammo--;
                launchSilo.indicators[launchSilo.ammo].visible = false;
                
                playLaunchSound();
              }
            };

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            // Spawn enemy missiles
            const spawnEnemyMissile = () => {
              if (gameState.citiesAlive === 0) return;

              const startX = (Math.random() - 0.5) * 100;
              const targetCity = gameState.cities[Math.floor(Math.random() * gameState.cities.length)];
              
              const missile = {
                start: new THREE.Vector3(startX, 30, 0),
                end: targetCity.position.clone(),
                current: new THREE.Vector3(startX, 30, 0),
                progress: 0,
                speed: 0.002 + Math.random() * 0.002,
                line: null
              };

              const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                missile.start,
                missile.current
              ]);
              const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
              missile.line = new THREE.Line(lineGeometry, lineMaterial);
              scene.add(missile.line);

              gameState.enemyMissiles.push(missile);
            };

            // Create explosion
            const createExplosion = (position, isPlayer = false) => {
              const explosion = {
                position: position.clone(),
                radius: 0,
                maxRadius: isPlayer ? 8 : 3,
                expanding: true,
                duration: isPlayer ? 120 : 60,
                life: 0,
                circle: null
              };

              const segments = 32;
              const circleGeometry = new THREE.BufferGeometry();
              const positions = new Float32Array((segments + 1) * 3);
              for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                positions[i * 3] = Math.cos(theta);
                positions[i * 3 + 1] = Math.sin(theta);
                positions[i * 3 + 2] = 0;
              }
              circleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
              
              const circleMaterial = new THREE.LineBasicMaterial({ 
                color: isPlayer ? 0xffffff : 0xff8800 
              });
              explosion.circle = new THREE.LineLoop(circleGeometry, circleMaterial);
              explosion.circle.position.copy(position);
              scene.add(explosion.circle);

              gameState.explosions.push(explosion);
              playExplosionSound(isPlayer);
            };

            // Game loop
            let enemySpawnTimer = 0;
            let waveEnemiesSpawned = 0;
            const enemiesPerWave = 10;

            const animate = () => {
              requestAnimationFrame(animate);

              // Spawn enemies
              if (waveEnemiesSpawned < enemiesPerWave + gameState.wave * 5) {
                enemySpawnTimer++;
                if (enemySpawnTimer > 120 - gameState.wave * 8) {
                  spawnEnemyMissile();
                  enemySpawnTimer = 0;
                  waveEnemiesSpawned++;
                }
              }

              // Update player missiles
              for (let i = gameState.playerMissiles.length - 1; i >= 0; i--) {
                const missile = gameState.playerMissiles[i];
                missile.progress += missile.speed;

                if (missile.progress >= 1) {
                  // Missile reached target - create explosion
                  createExplosion(missile.end, true);
                  scene.remove(missile.line);
                  gameState.playerMissiles.splice(i, 1);
                } else {
                  missile.current.lerpVectors(missile.start, missile.end, missile.progress);
                  const positions = missile.line.geometry.attributes.position.array;
                  positions[3] = missile.current.x;
                  positions[4] = missile.current.y;
                  positions[5] = missile.current.z;
                  missile.line.geometry.attributes.position.needsUpdate = true;
                }
              }

              // Update enemy missiles
              for (let i = gameState.enemyMissiles.length - 1; i >= 0; i--) {
                const missile = gameState.enemyMissiles[i];
                missile.progress += missile.speed;

                if (missile.progress >= 1) {
                  // Missile hit target
                  createExplosion(missile.end, false);
                  
                  // Destroy city if hit
                  for (const city of gameState.cities) {
                    if (city.userData.alive && city.position.distanceTo(missile.end) < 3) {
                      city.userData.alive = false;
                      city.material.color.setHex(0x330000);
                      gameState.citiesAlive--;
                      playCityDestroyedSound();
                    }
                  }

                  scene.remove(missile.line);
                  gameState.enemyMissiles.splice(i, 1);
                } else {
                  missile.current.lerpVectors(missile.start, missile.end, missile.progress);
                  const positions = missile.line.geometry.attributes.position.array;
                  positions[3] = missile.current.x;
                  positions[4] = missile.current.y;
                  positions[5] = missile.current.z;
                  missile.line.geometry.attributes.position.needsUpdate = true;
                }
              }

              // Update explosions and check collisions
              for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.life++;

                if (explosion.expanding) {
                  explosion.radius += explosion.maxRadius / 30;
                  if (explosion.radius >= explosion.maxRadius) {
                    explosion.expanding = false;
                  }
                }

                explosion.circle.scale.set(explosion.radius, explosion.radius, 1);

                // Check collision with enemy missiles
                if (explosion.radius > 0) {
                  for (let j = gameState.enemyMissiles.length - 1; j >= 0; j--) {
                    const missile = gameState.enemyMissiles[j];
                    if (missile.current.distanceTo(explosion.position) < explosion.radius) {
                      // Hit!
                      createExplosion(missile.current, false);
                      scene.remove(missile.line);
                      gameState.enemyMissiles.splice(j, 1);
                      gameState.score += 25;
                    }
                  }
                }

                if (explosion.life >= explosion.duration) {
                  scene.remove(explosion.circle);
                  gameState.explosions.splice(i, 1);
                }
              }

              // Check for wave completion
              if (gameState.enemyMissiles.length === 0 && 
                  waveEnemiesSpawned >= enemiesPerWave + gameState.wave * 5 &&
                  gameState.citiesAlive > 0) {
                gameState.wave++;
                gameState.score += gameState.citiesAlive * 100;
                
                // Refill all silos
                for (const silo of gameState.silos) {
                  for (let i = 0; i < 10; i++) {
                    silo.indicators[i].visible = true;
                  }
                  silo.ammo = 10;
                }
                
                waveEnemiesSpawned = 0;
                setWave(gameState.wave);
              }

              // Check game over
              if (gameState.citiesAlive === 0 && !gameOver) {
                setGameOver(true);
              }

              setScore(gameState.score);
              renderer.render(scene, camera);
            };

            animate();

            // Handle resize
            const handleResize = () => {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', handleResize);

            // Cleanup
            return () => {
              window.removeEventListener('mousemove', onMouseMove);
              window.removeEventListener('click', onMouseClick);
              window.removeEventListener('resize', handleResize);
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
            };
          }, []);

          const restartGame = () => {
            setGameOver(false);
            setScore(0);
            setWave(1);
            gameStateRef.current = {
              cities: [],
              silos: [],
              enemyMissiles: [],
              playerMissiles: [],
              explosions: [],
              score: 0,
              citiesAlive: 6,
              wave: 1
            };
          };

          return (
            <div className="relative w-full h-screen overflow-hidden bg-black">
              <div ref={mountRef} className="w-full h-full" />
              
              <div className="absolute top-4 left-4 text-green-400 font-mono text-xl">
                <div>SCORE: {score}</div>
                <div>WAVE: {wave}</div>
                <div>AMMO: {gameStateRef.current.silos.reduce((sum, silo) => sum + silo.ammo, 0)}</div>
                <div>CITIES: {gameStateRef.current.citiesAlive}</div>
              </div>

              {gameOver && (
                <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
                  <div className="text-center">
                    <h1 className="text-6xl font-bold text-red-500 mb-4">GAME OVER</h1>
                    <p className="text-3xl text-white mb-2">Final Score: {score}</p>
                    <p className="text-xl text-white mb-8">Wave: {wave}</p>
                    <button
                      onClick={restartGame}
                      className="px-8 py-4 bg-green-500 text-white text-2xl font-bold rounded hover:bg-green-600 transition-colors"
                    >
                      PLAY AGAIN
                    </button>
                  </div>
                </div>
              )}

              <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 text-white text-sm font-mono text-center">
                <p>Click to fire missiles at incoming threats</p>
                <p>Protect your cities!</p>
              </div>
            </div>
          );
        }

        ReactDOM.render(<MissileCommand />, document.getElementById('root'));
    </script>
</body>
</html>
